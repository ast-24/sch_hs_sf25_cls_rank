import { calcScore } from '../calc_score.mjs';
import { MyFatalError } from '../errors.mjs';
import { CONF } from '../../conf.mjs';

/**
 * 軽量版のユーザースコア更新（ランキング更新なし）
 * ランキング更新は別の非同期処理で実行
 */
export async function updateUserScoreLight(tidbCl, userDbId, tgtRoundIds = []) {
    await tidbCl.execInTxOptional(async (tidbCl) => {
        const placeholders = tgtRoundIds.map(() => '?').join(',');
        const roundAnswersRes = await tidbCl.query(`
            SELECT
                ur.id, ur.round_id, ur.room_id, ur.finished_at, ur.score, ura.is_correct
            FROM users_rounds ur
            JOIN users_rounds_answers ura ON ur.id = ura.round_id
            WHERE ur.user_id = ? AND ur.round_id IN (${placeholders})
            ORDER BY ura.answer_id ASC
            `, [userDbId, ...tgtRoundIds]
        );

        let roundAnswers = {};
        for (const row of roundAnswersRes) {
            if (!roundAnswers[row.round_id]) {
                roundAnswers[row.round_id] = {
                    dbId: row.id,
                    roomId: row.room_id,
                    finishedAt: row.finished_at,
                    score: row.score,
                    isCorrect: []
                };
            }
            roundAnswers[row.round_id].isCorrect.push(row.is_correct);
        }

        const scoreUpdates = [];
        for (const tgtRoundId of tgtRoundIds) {
            const roundData = roundAnswers[tgtRoundId];
            if (!roundData) continue;

            const newScore = roundData.finishedAt ? calcScore(0, roundData.isCorrect) : null;
            if (newScore !== roundData.score) {
                scoreUpdates.push([newScore, roundData.dbId]);
            }
        }

        if (scoreUpdates.length > 0) {
            if (scoreUpdates.length === 1) {
                const [score, dbId] = scoreUpdates[0];
                await tidbCl.query(`UPDATE users_rounds SET score = ? WHERE id = ?`, [score, dbId]);
            } else {
                const values = scoreUpdates.map(() => '(?, ?)').join(',');
                const params = scoreUpdates.flat();
                await tidbCl.query(`
                    INSERT INTO users_rounds (score, id) VALUES ${values}
                    ON DUPLICATE KEY UPDATE score = VALUES(score)
                `, params);
            }
        }

        if (scoreUpdates.length === 0) {
            return false; // 更新なし
        }

        if (CONF.RANKING.ENABLE.TOTAL || CONF.RANKING.ENABLE.ROUND_MAX) {
            const scoreCalcRes = await tidbCl.query(`
                SELECT SUM(score) as total_score, MAX(score) as max_score
                FROM users_rounds
                WHERE user_id = ? AND score IS NOT NULL
                `, [userDbId]
            );

            const newTotalScore = scoreCalcRes[0]?.total_score ?? null;
            const newRoundMaxScore = scoreCalcRes[0]?.max_score ?? null;

            await tidbCl.query(`
                UPDATE users SET score_total = ?, score_round_max = ? WHERE id = ?
                `, [newTotalScore, newRoundMaxScore, userDbId]
            );
        }

        // ランキング更新要求をキューに追加（実装時）
        // await enqueueRankingUpdate(userDbId, tgtRoundIds);

        return true; // 更新あり
    });
}
